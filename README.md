# L-2_assignment_2

## 1. What is PostgreSQL?

**উত্তর:** PostgreSQL একটি শক্তিশালী, ওপেন-সোর্স অবজেক্ট-রিলেশনাল ডাটাবেস সিস্টেম, যা এন্টারপ্রাইজ-লেভেলের পারফরমেন্স এবং নির্ভরযোগ্যতার জন্য ব্যাপকভাবে ব্যবহৃত হয়। এটি অসাধারণ কিছু বৈশিষ্ট্যের জন্য সুপরিচিত, যেমন: নমনীয়তা, স্থিতিশীলতা, বর্ধনযোগ্যতা এবং মান-অনুযায়ী সামঞ্জস্য। PostgreSQL উভয় ধরনের কোয়েরি সমর্থন করে SQL (রিলেশনাল) এবং JSON (নন-রিলেশনাল), যা এটিকে বিভিন্ন ধরনের অ্যাপ্লিকেশনের জন্য উপযোগী করে তোলে।

## 2. What is the purpose of a database schema in PostgreSQL?

**উত্তর:** PostgreSQL-এ স্কিমা হলো একটি যৌক্তিক কাঠামো বা কন্টেইনার, যা টেবিল, ভিউ, ইনডেক্স, ফাংশন এবং সিকোয়েন্সসহ বিভিন্ন ডাটাবেস অবজেক্ট ধারণ করে। এটি মূলত ডাটাবেসকে আরও গোছালো, নিরাপদ ও সহজভাবে ব্যবস্থাপনার জন্য ব্যবহৃত হয়।

স্কিমা ব্যবহারের প্রধান কারণগুলো হলো:

- সংগঠিত রাখা: স্কিমা সম্পর্কিত অবজেক্টগুলোকে একটি গ্রুপে রাখে, যা ডাটাবেসকে পরিষ্কার ও সহজে বোঝার উপযোগী করে তোলে।
- নেমস্পেস ম্যানেজমেন্ট: একই ডাটাবেসে একাধিক স্কিমা থাকার ফলে একাধিক টেবিল বা অবজেক্ট একই নামে থাকতে পারে, তাতে কোনো দ্বন্দ্ব হয় না।
- অ্যাক্সেস নিয়ন্ত্রণ: স্কিমা-ভিত্তিক পারমিশন সেট করা যায়, ফলে ব্যবহারকারীদের নির্দিষ্ট অবজেক্টে প্রবেশাধিকার নিয়ন্ত্রণ করা সহজ হয়।

সব মিলিয়ে, PostgreSQL-এ স্কিমা ব্যবহারের ফলে ডাটাবেসের গঠন আরও সুসংগঠিত হয়, নিরাপত্তা বৃদ্ধি পায় এবং রক্ষণাবেক্ষণ সহজ হয়।

## 3. Explain the Primary Key and Foreign Key concepts in PostgreSQL

**উত্তর:**  
আমরা জানি যে প্রাইমারি কি (Primary Key) এবং ফরেন কি (Foreign Key) একটি রিলেশনাল ডাটাবেস সিস্টেমের অত্যন্ত গুরুত্বপূর্ণ ধারণা। PostgreSQL-এ এই দুটি কী ব্যবহার করা হয় ডাটার সঠিকতা (data integrity) বজায় রাখতে এবং টেবিলগুলোর মধ্যে সম্পর্ক নির্ধারণ করতে।

### প্রাইমারি কি (Primary Key):

প্রাইমারি কি হলো একটি কলাম, যা টেবিলের প্রতিটি সারিকে (row) ইউনিকভাবে চিহ্নিত করে। এতে কোনো ডুপ্লিকেট (duplicate) বা NULL ভ্যালু থাকতে পারে না। একটি টেবিলে মাত্র একটি প্রাইমারি কি থাকতে পারে।

নিচে একটি উদাহরণ দেখানো হলো:

```sql
CREATE TABLE students (
    student_id SERIAL PRIMARY KEY,
    name VARCHAR(50)
);
```

### ফরেন কি (Foreign Key):

ফরেন কি হলো একটি কলাম (অথবা একাধিক কলাম), যা একটি টেবিলের মধ্যে থাকা অন্য একটি টেবিলের প্রাইমারি কির সাথে সম্পর্ক তৈরি করে। এটি দুটি টেবিলের মধ্যে একটি সম্পর্ক গড়ে তোলে এবং রেফারেনশিয়াল ইন্টেগ্রিটি (referential integrity) নিশ্চিত করে।

নিচে একটি উদাহরণ দেওয়া হলো:

```sql
CREATE TABLE enrollments (
    enrollment_id SERIAL PRIMARY KEY,
    student_id INT REFERENCES students(student_id),
    course_name VARCHAR(100)
);
```

এই উদাহরণে, `enrollments` টেবিলের `student_id` একটি ফরেন কি, যা `students` টেবিলের `student_id` প্রাইমারি কিকে রেফার করে। এর ফলে শুধুমাত্র বৈধ (অর্থাৎ `students` টেবিলে আগে থেকে থাকা) `student_id`-গুলোকেই `enrollments` টেবিলে যোগ করা যাবে। এটি ডাটাবেসে ডেটার সঠিকতা ও সংযুক্তির সুরক্ষা নিশ্চিত করে।

## 4. What is the difference between the VARCHAR and CHAR data types?

উত্তর: ডাটাবেসের প্রেক্ষাপটে, CHAR ডেটা টাইপটি নির্দিষ্ট দৈর্ঘ্যের (fixed-length) স্ট্রিং সংরক্ষণ করে, আর VARCHAR ব্যবহার করা হয় পরিবর্তনশীল দৈর্ঘ্যের (variable-length) স্ট্রিং সংরক্ষণের জন্য।  
দৈর্ঘ্য (Length):  
• CHAR: নির্দিষ্ট দৈর্ঘ্য। ডেটা ছোট হলেও স্ট্রিংটিকে নির্ধারিত দৈর্ঘ্যে পৌঁছাতে স্পেস (space) দ্বারা প্যাড করা হয়।  
• VARCHAR: পরিবর্তনশীল দৈর্ঘ্য। ডেটা নির্ধারিত সর্বোচ্চ দৈর্ঘ্যের চেয়ে ছোট হতে পারে এবং শুধুমাত্র প্রয়োজনীয় স্থানই ব্যবহার করে।  
সংরক্ষণ (Storage):  
• CHAR: কম কার্যকর, কারণ এটি সবসময় সর্বোচ্চ দৈর্ঘ্যের জন্য স্পেস সংরক্ষণ করে, এমনকি ডেটা ছোট হলেও।  
• VARCHAR: বেশি কার্যকর, কারণ এটি শুধু ডেটার প্রকৃত দৈর্ঘ্য অনুযায়ী স্পেস ব্যবহার করে।

এখন আমরা একটি কোডিং উদাহরণের মাধ্যমে দেখব:  
CREATE TABLE example_char_varchar (  
    fixed_name CHAR(10),  
    variable_name VARCHAR(10)  
);

INSERT INTO example_char_varchar (fixed_name, variable_name)  
VALUES ('Nazrul', 'Nazrul');

এই ক্ষেত্রে,  
• fixed_name ভ্যালুটি 'Nazrul    ' হিসেবে সংরক্ষণ করবে (অতিরিক্ত ৪টি স্পেসসহ)।  
• variable_name ভ্যালুটি 'Nazrul' হিসেবেই সংরক্ষণ করবে (কোনো অতিরিক্ত স্পেস ছাড়াই)।

## 5. Explain the purpose of the WHERE clause in a SELECT statement

উত্তর: WHERE ক্লজ SELECT স্টেটমেন্টের সঙ্গে ব্যবহার করা হয় ডাটাবেস থেকে ডেটা নির্বাচনের সময় নির্দিষ্ট শর্ত আরোপ করার জন্য। এর সাহায্যে আমরা যেসব রেকর্ড দরকার, শুধুমাত্র সেগুলোই বের করতে পারি। যদি WHERE না দিয়ে সব ডেটা আনা হয়, তাহলে অনেক অপ্রয়োজনীয় তথ্যও চলে আসতে পারে, যা বিশ্লেষণ করা কঠিন হয়ে পড়ে।

উদাহরণ দিয়ে বুঝি:  
SELECT \* FROM students  
WHERE department = 'CSE';  
এখানে শুধুমাত্র CSE ডিপার্টমেন্টের ছাত্রদের তথ্য দেখাবে।


## 6. What are the LIMIT and OFFSET clauses used for?  

উত্তর: LIMIT এবং OFFSET ক্লজ দুটো ডাটাবেস থেকে ডেটা নিয়ে আসার সময় ব্যবহৃত হয়।  
•	LIMIT দিয়ে আমরা ঠিক করি কতগুলো রেকর্ড ফিরিয়ে আনব, অর্থাৎ রেজাল্ট কতগুলো আইটেমে সীমাবদ্ধ থাকবে।  
•	OFFSET দিয়ে নির্দিষ্ট সংখ্যক রেকর্ড স্কিপ করে পরের থেকে রেজাল্ট দেখানো হয়। এটা সাধারণত পেজিং বা ভাগে ভাগে ডেটা দেখানোর জন্য ব্যবহৃত হয়।  

উদাহরণ:  
SELECT * FROM students  
LIMIT 5 OFFSET 10;  
এই কোয়েরিটা প্রথম ১০টা রেকর্ড বাদ দিয়ে পরের ৫টা রেকর্ড দেখাবে।


## 7. How can you modify data using UPDATE statements?  
উত্তর:  
UPDATE স্টেটমেন্ট ব্যবহার করে ডাটাবেসের টেবিলের বিদ্যমান ডেটা পরিবর্তন করা হয়। এতে আমরা কোন টেবিলের কোন কলামগুলোর মান কীভাবে পরিবর্তন করব তা নির্দিষ্ট করতে পারি।  
UPDATE এর সাথে সাধারণত WHERE ক্লজ ব্যবহার করা হয়, যাতে নির্দিষ্ট শর্ত মিলে এমন রেকর্ডগুলোই আপডেট হয়। যদি WHERE না দেওয়া হয়, তাহলে টেবিলের সব রেকর্ড আপডেট হয়ে যাবে।

সিনট্যাক্স:  
UPDATE table_name  
SET column1 = value1, column2 = value2, ...  
WHERE condition;  

উদাহরণ:  
UPDATE students  
SET name = 'Rahim', age = 22  
WHERE student_id = 1;  

এই কোয়েরি students টেবিলের সেই রেকর্ডের name এবং age আপডেট করবে যেখানের student_id 1.


## 8. What is the significance of the JOIN operation, and how does it work in PostgreSQL?  

উত্তর: JOIN অপারেশন ডাটাবেসে দুই বা তার বেশি টেবিলের ডেটা একসাথে যোগ করার জন্য ব্যবহার করা হয়। এর মাধ্যমে আমরা সম্পর্কযুক্ত টেবিল থেকে প্রয়োজনীয় তথ্য একত্রে এনে বিশ্লেষণ বা প্রদর্শন করতে পারি।  
PostgreSQL-এ JOIN মূলত দুটি টেবিলের মধ্যে নির্দিষ্ট কলামের উপর ভিত্তি করে মিল খুঁজে সেই মিলের ডেটা নিয়ে আসে।

JOIN এর ধরনগুলো:  
•	INNER JOIN: শুধু দুই টেবিলের মিল থাকা রেকর্ডগুলো ফিরিয়ে আনে।  
•	LEFT JOIN: বাম (প্রথম) টেবিলের সব রেকর্ড নিয়ে আসে, মিল না থাকলেও; আর ডান টেবিলের মিল না থাকলে NULL দেখায়।  
•	RIGHT JOIN: ডান (দ্বিতীয়) টেবিলের সব রেকর্ড নিয়ে আসে, মিল না থাকলেও; বাম টেবিলের জন্য NULL দেয়।  
•	FULL JOIN: দুই টেবিলের সব রেকর্ড নিয়ে আসে, মিল না থাকলেও NULL দিয়ে দেখায়।  

উদাহরণ (INNER JOIN):  
SELECT students.name, enrollments.course_name  
FROM students  
INNER JOIN enrollments ON students.student_id = enrollments.student_id;  

এখানে students এবং enrollments টেবিলের মিল থাকা রেকর্ডগুলো নিয়ে ছাত্রের নাম ও তাদের কোর্সের নাম দেখানো হবে।  
একজন প্রকৌশলী বা ডাটাবেস ইঞ্জিনিয়ারের জন্য JOIN এর ধারণা জানা খুবই জরুরি, কারণ বাস্তব জীবনে ডাটাবেসে ডেটা প্রায়ই বিভিন্ন টেবিলে বিভক্ত থাকে। সফলভাবে কাজ করার জন্য, টেবিলগুলোকে যুক্ত করে সঠিক তথ্য পাওয়া দরকার।


## 9. Explain the GROUP BY clause and its role in aggregation operations.  
উত্তর: GROUP BY ক্লজ ব্যবহার করা হয় ডাটাবেসের রেকর্ডগুলোকে নির্দিষ্ট একটি বা একাধিক কলামের ভিত্তিতে গ্রুপ করার জন্য। এর প্রধান কাজ হলো একই ধরনের ডেটাকে একসাথে নিয়ে আসা যাতে আমরা সেই গ্রুপের উপর বিভিন্ন এগ্রিগেশন (aggregation) ফাংশন যেমন SUM(), COUNT(), AVG(), MAX(), MIN() ইত্যাদি প্রয়োগ করতে পারি।

উদাহরণ:  
ধরুন, আমাদের কাছে একটি sales টেবিল আছে যেখানে product এবং amount কলাম আছে। আমরা চাই প্রতিটি প্রোডাক্টের মোট বিক্রয় কত?  
SELECT product, SUM(amount)  
FROM sales  
GROUP BY product;  

সংক্ষিপ্তভাবে:  
•	GROUP BY ডেটা ভাগ করে গ্রুপ তৈরি করে।  
•	এগ্রিগেশন ফাংশনের সাথে ব্যবহার করে গ্রুপ ভিত্তিক হিসাব করতে সাহায্য করে।


## 10.	How can you calculate aggregate functions like COUNT(), SUM(), and AVG() in PostgreSQL?  
উত্তর: PostgreSQL-এ COUNT(), SUM(), এবং AVG() হলো এগ্রিগেট ফাংশন যা ডেটার উপর বিভিন্ন গণনা করার জন্য ব্যবহৃত হয়।  
•	COUNT(): কোনও কলামের মোট রেকর্ড সংখ্যা বা নির্দিষ্ট শর্ত পূরণ করা রেকর্ড সংখ্যা বের করে।  
•	SUM(): একটি সংখ্যাগত কলামের সব মান যোগ করে।  
•	AVG(): একটি সংখ্যাগত কলামের গড় মান হিসাব করে।  

উদাহরণ:  
ধরুন, আমাদের একটি sales টেবিল আছে যেখানে amount নামে একটি কলাম আছে।  
SELECT COUNT(*) AS total_sales,  
       SUM(amount) AS total_amount,  
       AVG(amount) AS average_amount  
FROM sales;

এখানে:  
•	COUNT(*) দেখাবে মোট কতগুলো সেলস রেকর্ড আছে।  
•	SUM(amount) দেখাবে মোট বিক্রয় অর্থ কত।  
•	AVG(amount) দেখাবে গড় বিক্রয় অর্থ কত।



